package thread.capter05;

import org.openjdk.jol.info.ClassLayout;

/**
 ************************ Monitor 监控锁 ***************************
 java中每一个对象都可以关联一个Monitor对象
 Monitor对象分为三个部分：
 |------------------------------|
 |  wait set                    |
 |                              |
 |------------------------------|
 |                              |
 |  owner                       |
 |                              |
 |------------------------------|
 |                              |
 |  entry set                   |
 |                              |
 |------------------------------|
    其中每一个monitor的owner都可以关联一个对象。
    当使用synchronized锁住代码块后，如果使用的锁类型是重量级锁，那么被锁住的对象头的mark word的前30bit指向与他关联的monitor锁地址，
 同时该monitor的owner记录了当前线程的id（此处的线程id是java线程绑定的操作系统原生线程的id）
    此时如果有其他线程进入到临界区需要获取到对象锁时，则会检查owner是否有指向的线程，如果有指向的线程则判断指向的是否是当前线程，如果
 是当前线程，则允许进入（即synchronized是允许重入的）；如果owner有指向线程，并且记录的不是当前线程，那么该线程则会进入entry set等待
 此时如果owner指向的线程调用了wait方法，需要满足一定的条件才能操作，则会进入wait set等待，将owner让出给其他线程
    此时如果monitor指向的线程已经执行完毕，在退出临界区的时候则会将owner清空，且唤醒entry set中的所有线程争夺owner(此处说明monitor锁是非公平的)
官方解释：
 1.刚开始 Monitor 中 Owner 为 null
 2.当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner
 3.在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED
 4.Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的
 5.图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析
 注意：
 1.synchronized 必须是进入同一个对象的 monitor 才有上述的效果
 2.不加 synchronized 的对象不会关联监视器，不遵从以上规则


 ************************ 基于字节码分析有无锁情况下字节码的区别 ************************
  无锁的字节码：
 0: getstatic     #2                  // Field count:I
 3: iconst_1
 4: iadd
 5: putstatic     #2                  // Field count:I
 8: return


 有锁的字节码：
 0: getstatic     #2                  // Field lock:Ljava/lang/Object;<---------获取lock的引用（synchronized的开始）
 3: dup<------------------------------------------------------------------------拷贝一份用于后面解锁使用
 4: astore_1<-------------------------------------------------------------------存储lock引用 -> slot 1
 5: monitorenter<--进入monitor锁，也就是 1.将lock对象头中的锁类型部分修改为重量级锁状态；2.将markWord中前30/62位修改为该对象关联的Monitor对象的指针；3.将Monitor对象的owner指向当前线程的id
 6: getstatic     #3                  // Field count:I<-------------------------获取静态变量count
 9: iconst_1<--------------------------------------------------------------------准备常量1
 10: iadd<-----------------------------------------------------------------------将count与i进行相加
 11: putstatic     #3                  // Field count:I<-------------------------将递增后的值存入到count静态变量中
 14: aload_1<-------------------------------------------------------------------加载lock的引用
 15: monitorexit<---------------------------------------------------------------将lock对象头中的markword重置，并且唤醒该对象关联的monitor对象的entryList中等待锁的线程
 16: goto          24<----------------------------------------------------------跳转至24行
 19: astore_2<------------------------------------------------------------------e(异常对象)->slot 2
 20: aload_1<------------------------------------------------------------------加载lock引用
 21: monitorexit<--------------------------------------------------------------重置lock对象头中的markword，并且唤醒该对象关联的monitor对象的entryList中等待锁的线程
 22: aload_2<------------------------------------------------------------------从slot 2中加载e(异常对象)
 23: athrow<------------------------------------------------------------------ throw e
 24: return<-------------------------------------------------------------------退出函数


 ************************ java中对象头的结构分析 ************************
 java中的普通对象的对象头结构：
 java 对象头在32位虚拟机中一共占64位，即8个字节，其中前32位是mark Word 后32位是    Klass Word
 Mark word中主要存储对象的hashcode，分代年龄，锁类型以及对应不同锁类型存储的信息
 Klass Word中存储的是该对象所属类型信息，即存储的是该对象的Class对象的指针
 |--------------------------------------------------------------|
 |                      Object Header (64 bits)                 |
 |------------------------------------|-------------------------|
 | Mark Word (32 bits)                | Klass Word (32 bits) |
 |------------------------------------|-------------------------|

 java中数组对象的对象头结构：
 java中数组对象头除了Mark Word和Klass Word信息之外，还有32位用来存储对象的长度
 |---------------------------------------------------------------------------------|
 |                   Object Header (96 bits)                                       |
 |--------------------------------|-----------------------|------------------------|
 | Mark Word(32bits)              | Klass Word(32bits)    | array length(32bits)   |
 |--------------------------------|-----------------------|------------------------|


 ************************ java中对象头中Mark word中锁类型相关信息 ************************
 *
 32位java虚拟机中对象的Mark Word中的具体信息：
 对象头中的状态分为五种，分别是：正常状态、偏向锁状态、轻量级锁状态、重量级锁状态、GC标记状态
 1.正常状态：正常状态下，Mark Word主要分为4个部分，前25 bit存放的是对象的hashCode，紧接着4 bit存储对象的分代年龄，紧接着1 bit存储对象的偏向状态，
   0表示无偏向，即无偏向锁，最后2 bit存储对象当前的锁类型，01表示normal状态；即normal状态的对象头中的mark word最后三位是001
 2.偏向状态：偏向状态下，Mark Word主要分为5个部分，前23bit存放的是偏向线程的id(此处的线程id实际上是映射到操作系统的线程id)，紧接着2bit存放的是epoch
   紧接着4bit存放的是分代年龄，紧接着1bit存放的是是否偏向状态，即1表示是偏向状态，0表示是正常状态，最后两位存放的是01；即偏向状态的对象头中的mark word最后三位是101
 3.轻量级锁状态：轻量级锁状态下，Mark Word主要分为2个部分，前30bit存放的是持有锁的线程的锁记录的地址（每个线程的每个栈帧都有一个锁记录的结构，内部存储了锁定对象的Mark Word），
   紧接着2bit存放的是当前对象的锁状态，此时是00，即轻量级锁状态
 4.重量级锁状态：重量级锁状态下，Mark Word主要分为2个部分，前30bit存放的是该对象关联的monitor对象地址，紧接着2bit存放的是当前对象的锁状态，此时是10，即表示重量级锁状态

 |-------------------------------------------------------|--------------------|
 |                          Mark Word (32 bits)          | State              |
 |-------------------------------------------------------|--------------------|
 | hashcode:25          | age:4 | biased_lock:0 | 01     | Normal             |
 |-------------------------------------------------------|--------------------|
 | thread:23 | epoch:2 | age:4 | biased_lock:1 | 01      | Biased             |
 |-------------------------------------------------------|--------------------|
 | ptr_to_lock_record:30                      | 00        | Lightweight Locked |
 |-------------------------------------------------------|--------------------|
 | ptr_to_heavyweight_monitor:30              | 10       | Heavyweight Locked |
 |-------------------------------------------------------|--------------------|
 |                                            | 11       | Marked for GC      |
 |-------------------------------------------------------|--------------------|
 例如某普通对象的对象头（32bit）：
 mark word                                   Klass word
 加锁前：
 00000001 00000000 00000000 00000000        00000000 00000000 00000000 00000000
 加锁后：
 01100000 11111000 10111010 00000010        00000000 00000000 00000000 00000000


 ************************ java偏向锁、轻量级锁、重量级锁 ************************
 synchronized monitor重量级锁的缺点：由于Monitor
 java 1.6之后对synchronized关键字做了一系列的优化
 一、偏向锁
 二、轻量级锁
 轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化，例如lightLock()方法。
 三、重量级锁
 重量级锁底层使用monitor对象进行加锁，依赖于系统的同步函数实现代码的同步。在linux中使用的是mutex互斥锁，当使用monitor锁时，会涉及到内核态与用户态的转换，
 所以使用Monitor锁在没有多线程竞争或只有少量的竞争情况下，性能较低。










 */
public class Main {
    static final Object lock = new Object();
    static int count = 0;

    public static void main(String[] args) {
        synchronized (lock){
            System.out.println(ClassLayout.parseInstance(lock).toPrintable());
        }
//        synchronized (lock){
//            count++;
//        }
    }

    /**
     * 轻量级锁
     */
    public void lightLock(){
        method1();
    }
    public void method1(){
        synchronized (lock){
            method2();
        }
    }
    public void method2(){
        synchronized (lock){
            System.err.println("---");
        }
    }
}
